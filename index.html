<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="theme-color" content="#000000">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<title>Pac-Man Arcade</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html {
    height: 100%;
    overflow: hidden;
    overscroll-behavior: none;
  }

  body {
    font-family: 'Press Start 2P', monospace;
    user-select: none;
    overflow: hidden;
    height: 100vh;
    height: 100dvh;
    background: #050508;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    overscroll-behavior: none;
    position: fixed;
    inset: 0;
  }

  .arcade-room {
    position: fixed;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    perspective: 800px;
  }

  .wall {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 55%;
    background:
      repeating-linear-gradient(90deg, transparent, transparent 198px, #1a1520 198px, #1a1520 200px),
      repeating-linear-gradient(180deg, transparent, transparent 98px, #1a1520 98px, #1a1520 100px),
      linear-gradient(180deg, #0d0a12 0%, #151020 100%);
  }

  .floor {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    height: 50%;
    background:
      repeating-conic-gradient(#12101a 0% 25%, #0e0c16 0% 50%) 0 0 / 60px 60px;
    transform: perspective(400px) rotateX(35deg);
    transform-origin: top center;
  }

  .neon-sign {
    position: absolute;
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    letter-spacing: 4px;
    animation: neon-flicker 3s infinite;
  }
  .neon-sign.left {
    top: 8%; left: 8%;
    color: #ff2d55;
    text-shadow: 0 0 10px #ff2d55, 0 0 30px #ff2d55, 0 0 60px #ff2d55;
    transform: rotate(-5deg);
  }
  .neon-sign.right {
    top: 12%; right: 7%;
    color: #00e5ff;
    text-shadow: 0 0 10px #00e5ff, 0 0 30px #00e5ff, 0 0 60px #00e5ff;
    transform: rotate(3deg);
  }

  .bg-cabinet {
    position: absolute;
    bottom: 8%;
    width: 120px;
    height: 340px;
    border-radius: 8px 8px 0 0;
    opacity: 0.3;
  }
  .bg-cabinet::before {
    content: '';
    position: absolute;
    top: 20px; left: 15px; right: 15px;
    height: 80px;
    border-radius: 4px;
    background: #000;
  }
  .bg-cabinet.c1 { left: 5%; background: linear-gradient(180deg, #2a1a3a, #1a1025); transform: perspective(400px) rotateY(15deg); }
  .bg-cabinet.c1::before { box-shadow: 0 0 20px rgba(255,50,50,0.3); }
  .bg-cabinet.c2 { left: 16%; background: linear-gradient(180deg, #1a2a3a, #101a25); transform: perspective(400px) rotateY(10deg); }
  .bg-cabinet.c2::before { box-shadow: 0 0 20px rgba(50,255,50,0.3); }
  .bg-cabinet.c3 { right: 5%; background: linear-gradient(180deg, #3a2a1a, #251a10); transform: perspective(400px) rotateY(-15deg); }
  .bg-cabinet.c3::before { box-shadow: 0 0 20px rgba(50,50,255,0.3); }
  .bg-cabinet.c4 { right: 16%; background: linear-gradient(180deg, #2a3a1a, #1a2510); transform: perspective(400px) rotateY(-10deg); }
  .bg-cabinet.c4::before { box-shadow: 0 0 20px rgba(255,255,50,0.3); }

  .ambient-light {
    position: absolute;
    border-radius: 50%;
    filter: blur(60px);
    pointer-events: none;
  }
  .ambient-light.a1 { top: -5%; left: 30%; width: 300px; height: 200px; background: rgba(33,33,222,0.06); }
  .ambient-light.a2 { top: -5%; right: 30%; width: 300px; height: 200px; background: rgba(222,33,100,0.05); }
  .ambient-light.a3 { bottom: 10%; left: 50%; width: 500px; height: 300px; background: rgba(33,33,222,0.04); transform: translateX(-50%); }

  .cabinet {
    position: relative;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    filter: drop-shadow(0 0 40px rgba(0,0,0,0.8));
  }

  .marquee {
    width: 520px;
    height: 70px;
    background: linear-gradient(180deg, #1a0a2e 0%, #0d0520 40%, #1a0a2e 100%);
    border-radius: 16px 16px 0 0;
    border: 3px solid #333;
    border-bottom: none;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }
  .marquee-text {
    font-size: 28px;
    color: #ffff00;
    text-shadow: 0 0 10px #ffff00, 0 0 30px #ffaa00, 0 0 60px #ff6600, 0 0 80px #ff3300;
    letter-spacing: 8px;
    z-index: 2;
    animation: marquee-glow 2s ease-in-out infinite alternate;
  }
  .marquee::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at center, rgba(255,255,0,0.08) 0%, transparent 70%);
  }
  .marquee-strip {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    height: 4px;
    background: repeating-linear-gradient(90deg, #ff0 0px, #ff0 8px, transparent 8px, transparent 16px);
    animation: marquee-scroll 1s linear infinite;
  }

  .cabinet-body {
    width: 520px;
    background: linear-gradient(180deg, #1c1c24 0%, #141418 50%, #1c1c24 100%);
    border-left: 3px solid #333;
    border-right: 3px solid #333;
    padding: 16px 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    position: relative;
  }

  .side-art-left, .side-art-right {
    position: absolute;
    top: 0; bottom: 0;
    width: 24px;
    overflow: hidden;
  }
  .side-art-left {
    left: 0;
    background: repeating-linear-gradient(180deg, #ffff00 0px, #ffff00 3px, #ff6600 3px, #ff6600 6px, #ff0000 6px, #ff0000 9px, transparent 9px, transparent 30px);
    opacity: 0.15;
  }
  .side-art-right {
    right: 0;
    background: repeating-linear-gradient(180deg, #00ffff 0px, #00ffff 3px, #0066ff 3px, #0066ff 6px, #ff00ff 6px, #ff00ff 9px, transparent 9px, transparent 30px);
    opacity: 0.15;
  }

  .hud {
    width: 100%;
    display: flex;
    justify-content: space-between;
    font-size: 9px;
    letter-spacing: 1px;
    color: #ddd;
    text-shadow: 0 0 6px rgba(255,255,255,0.3);
    padding: 0 16px;
    z-index: 2;
  }
  .hud .score { color: #fff; }
  .hud .best { color: #ffb8ff; }
  .lives { color: #ffff00; font-size: 14px; letter-spacing: 4px; }

  .screen-frame {
    background: #000;
    border-radius: 10px;
    padding: 6px;
    box-shadow:
      inset 0 0 30px rgba(0,0,0,0.8),
      0 0 20px rgba(33,33,222,0.15),
      0 0 60px rgba(33,33,222,0.06);
    z-index: 2;
  }
  .screen {
    position: relative;
    border-radius: 6px;
    overflow: hidden;
  }
  canvas {
    display: block;
    filter: brightness(1.15) contrast(1.2) saturate(1.3);
  }

  .scanlines {
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(0deg, rgba(0,0,0,0) 0px, rgba(0,0,0,0) 1px, rgba(0,0,0,0.25) 1px, rgba(0,0,0,0.25) 2px);
    pointer-events: none;
    z-index: 2;
  }
  .vignette {
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse 75% 75% at 50% 50%, transparent 40%, rgba(0,0,0,0.75) 100%);
    pointer-events: none;
    z-index: 3;
  }
  .flicker {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 4;
    animation: crt-flicker 4s linear infinite;
  }
  .reflection {
    position: absolute;
    top: 2%; left: 3%;
    width: 45%; height: 20%;
    background: linear-gradient(155deg, rgba(255,255,255,0.06) 0%, transparent 100%);
    border-radius: 50%;
    pointer-events: none;
    z-index: 5;
  }
  .rgb-shift {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 6;
    mix-blend-mode: screen;
    opacity: 0.04;
    background: repeating-linear-gradient(90deg, #f00 0px, transparent 1px, transparent 2px, #0f0 2px, transparent 3px, transparent 4px, #00f 4px, transparent 5px, transparent 6px);
  }

  .control-panel {
    width: 520px;
    height: 100px;
    background:
      linear-gradient(180deg, #22222c 0%, #18181f 40%, #121217 100%);
    border-left: 3px solid #333;
    border-right: 3px solid #333;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 60px;
    position: relative;
    overflow: hidden;
  }
  .control-panel::before {
    content: '';
    position: absolute;
    inset: 0;
    background:
      radial-gradient(ellipse 120px 80px at 30% 50%, rgba(255,255,255,0.03) 0%, transparent 100%),
      radial-gradient(ellipse 120px 80px at 70% 50%, rgba(255,255,255,0.02) 0%, transparent 100%);
    pointer-events: none;
  }
  .control-panel::after {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent 10%, rgba(255,255,255,0.08) 50%, transparent 90%);
  }

  .joy-mount {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .joy-plate {
    width: 80px; height: 80px;
    background: radial-gradient(circle at 50% 45%, #2a2a32, #1a1a20);
    border-radius: 12px;
    border: 2px solid #3a3a42;
    box-shadow: inset 0 1px 3px rgba(255,255,255,0.05), 0 2px 8px rgba(0,0,0,0.6);
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .joy-boot {
    width: 36px; height: 36px;
    background: radial-gradient(circle at 50% 50%, #1a1a1a, #0a0a0a);
    border-radius: 50%;
    border: 2px solid #333;
    box-shadow: 0 0 6px rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .joy-stick {
    width: 20px; height: 20px;
    background: radial-gradient(circle at 38% 32%, #666, #2a2a2a);
    border-radius: 50%;
    border: 1px solid #555;
    box-shadow: 0 3px 8px rgba(0,0,0,0.7), inset 0 1px 2px rgba(255,255,255,0.15);
    position: relative;
  }
  .joy-stick::after {
    content: '';
    position: absolute;
    top: 3px; left: 4px;
    width: 6px; height: 4px;
    background: radial-gradient(ellipse, rgba(255,255,255,0.2), transparent);
    border-radius: 50%;
  }

  .btn-group {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .btn-col {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
  }
  .btn-label {
    font-size: 5px;
    color: rgba(255,255,255,0.3);
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  .btn {
    width: 38px; height: 38px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.12);
    box-shadow: 0 4px 8px rgba(0,0,0,0.6), inset 0 1px 3px rgba(255,255,255,0.12), inset 0 -2px 4px rgba(0,0,0,0.3);
    position: relative;
  }
  .btn::after {
    content: '';
    position: absolute;
    top: 4px; left: 6px;
    width: 12px; height: 6px;
    background: radial-gradient(ellipse, rgba(255,255,255,0.2), transparent);
    border-radius: 50%;
  }
  .btn.red { background: radial-gradient(circle at 40% 32%, #ff5555, #cc1111, #880000); }
  .btn.blue { background: radial-gradient(circle at 40% 32%, #5599ff, #1155cc, #003388); }
  .btn.yellow { background: radial-gradient(circle at 40% 32%, #ffdd33, #ccaa00, #886600); }
  .btn-start {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
    margin-left: 16px;
  }
  .btn-start .btn-sm {
    width: 24px; height: 24px;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 32%, #f5f5f5, #aaa, #777);
    border: 2px solid rgba(255,255,255,0.2);
    box-shadow: 0 3px 6px rgba(0,0,0,0.5), inset 0 1px 2px rgba(255,255,255,0.3);
  }
  .btn-start .btn-label { color: rgba(255,255,255,0.5); font-size: 5px; }

  .lower-panel {
    width: 520px;
    background: linear-gradient(180deg, #111115 0%, #0c0c0f 100%);
    border-left: 3px solid #333;
    border-right: 3px solid #333;
    border-bottom: 3px solid #333;
    border-radius: 0 0 8px 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px 0 12px;
    gap: 8px;
    position: relative;
  }
  .lower-panel::before {
    content: '';
    position: absolute;
    top: 0; left: 20px; right: 20px;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.06), transparent);
  }

  .coin-row {
    display: flex;
    align-items: center;
    gap: 14px;
  }
  .coin-slot {
    width: 48px; height: 8px;
    background: #050505;
    border-radius: 4px;
    border: 2px solid #3a3a3a;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.9), 0 1px 0 rgba(255,255,255,0.04);
    position: relative;
  }
  .coin-slot::before {
    content: 'COIN';
    position: absolute;
    top: -14px; left: 50%;
    transform: translateX(-50%);
    font-size: 5px;
    color: rgba(255,255,255,0.25);
    letter-spacing: 2px;
    white-space: nowrap;
  }
  .coin-text {
    font-size: 8px;
    color: #ff6600;
    text-shadow: 0 0 10px rgba(255,100,0,0.6), 0 0 20px rgba(255,100,0,0.2);
    letter-spacing: 3px;
    animation: coin-blink 1.5s ease-in-out infinite;
  }

  .hint {
    font-size: 7px;
    color: rgba(255,255,255,0.3);
    letter-spacing: 1px;
    z-index: 20;
  }

  @keyframes neon-flicker {
    0%, 95%, 100% { opacity: 1; }
    96% { opacity: 0.6; }
    97% { opacity: 1; }
    98% { opacity: 0.7; }
  }
  @keyframes marquee-glow {
    0% { text-shadow: 0 0 10px #ffff00, 0 0 30px #ffaa00, 0 0 60px #ff6600; }
    100% { text-shadow: 0 0 15px #ffff00, 0 0 40px #ffaa00, 0 0 80px #ff6600, 0 0 100px #ff3300; }
  }
  @keyframes marquee-scroll {
    0% { transform: translateX(0); }
    100% { transform: translateX(16px); }
  }
  @keyframes crt-flicker {
    0% { opacity: 0; } 5% { opacity: 0; } 5.1% { opacity: 0.06; } 5.2% { opacity: 0; }
    40% { opacity: 0; } 40.1% { opacity: 0.04; } 40.2% { opacity: 0; }
    70% { opacity: 0; } 70.1% { opacity: 0.05; } 70.2% { opacity: 0; } 100% { opacity: 0; }
  }
  @keyframes coin-blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .touch-controls { display: none; }

  .joy-base {
    width: 140px;
    height: 140px;
    border-radius: 50%;
    background: rgba(255,255,255,0.08);
    border: 2px solid rgba(255,255,255,0.25);
    position: relative;
    margin: 0 auto;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
  }

  .joy-knob {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 35%, rgba(255,255,255,0.35), rgba(255,255,255,0.15));
    border: 2px solid rgba(255,255,255,0.4);
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    transition: background 0.1s, border-color 0.1s;
    will-change: transform;
  }
  .joy-knob.active {
    background: radial-gradient(circle at 40% 35%, rgba(255,255,0,0.5), rgba(255,255,0,0.2));
    border-color: rgba(255,255,0,0.7);
  }

  .joy-arrows {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }
  .joy-arrow {
    position: absolute;
    width: 16px;
    height: 16px;
    fill: rgba(255,255,255,0.3);
    transition: fill 0.1s;
  }
  .joy-arrow-up    { top: 8px; left: 50%; transform: translateX(-50%); }
  .joy-arrow-down  { bottom: 8px; left: 50%; transform: translateX(-50%); }
  .joy-arrow-left  { left: 8px; top: 50%; transform: translateY(-50%); }
  .joy-arrow-right { right: 8px; top: 50%; transform: translateY(-50%); }
  .joy-arrow.lit { fill: rgba(255,255,0,0.8); }

  @media (pointer: coarse) {
    .mobile-layout {
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
      padding-top: env(safe-area-inset-top, 0px);
      padding-bottom: env(safe-area-inset-bottom, 0px);
      background: #000;
    }

    .mobile-layout .arcade-room { display: none; }

    .mobile-layout .mobile-hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      font-size: 9px;
      letter-spacing: 1px;
      color: #ddd;
      flex-shrink: 0;
    }
    .mobile-layout .mobile-hud .score { color: #fff; }
    .mobile-layout .mobile-hud .best { color: #ffb8ff; }
    .mobile-layout .mobile-hud .lives { color: #ffff00; font-size: 14px; letter-spacing: 4px; }

    .mobile-layout .mobile-screen-wrap {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      padding: 0 4px;
    }

    .mobile-layout .mobile-screen {
      position: relative;
      border-radius: 4px;
      overflow: hidden;
      max-width: 100%;
      max-height: 100%;
      aspect-ratio: 448 / 496;
      background: #000;
    }

    .mobile-layout .mobile-screen canvas {
      width: 100%;
      height: 100%;
      display: block;
      filter: brightness(1.1) saturate(1.15);
    }

    .mobile-layout .mobile-screen .scanlines {
      position: absolute; inset: 0; pointer-events: none; z-index: 2;
      background: repeating-linear-gradient(0deg, rgba(0,0,0,0) 0px, rgba(0,0,0,0) 2px, rgba(0,0,0,0.12) 2px, rgba(0,0,0,0.12) 4px);
    }
    .mobile-layout .mobile-screen .vignette {
      position: absolute; inset: 0; pointer-events: none; z-index: 3;
      background: radial-gradient(ellipse 85% 85% at 50% 50%, transparent 50%, rgba(0,0,0,0.5) 100%);
    }

    .mobile-layout .touch-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      bottom: auto; left: auto; right: auto;
      transform: none;
      width: auto;
      min-height: 160px;
      margin: 8px auto 12px;
      flex-shrink: 0;
    }
  }

  @media (pointer: coarse) and (orientation: landscape) {
    .mobile-layout {
      flex-direction: row;
      padding-left: env(safe-area-inset-left, 0px);
      padding-right: env(safe-area-inset-right, 0px);
    }
    .mobile-layout .mobile-hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 20;
      padding: 4px 16px;
      font-size: 8px;
      background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
    }
    .mobile-layout .mobile-screen-wrap {
      flex: 1;
      padding: 24px 4px 4px;
    }
    .mobile-layout .touch-controls {
      width: auto;
      height: auto;
      margin: auto 20px;
      flex-shrink: 0;
    }
  }
</style>
</head>
<body>

<div class="mobile-layout" id="mobileLayout" style="display:none">
  <div class="mobile-hud">
    <span class="score">SCORE <span class="m-score">0</span></span>
    <span class="lives m-lives"></span>
    <span class="best">HIGH <span class="m-best">0</span></span>
  </div>
  <div class="mobile-screen-wrap">
    <div class="mobile-screen" id="mobileScreen">
      <div class="scanlines"></div>
      <div class="vignette"></div>
    </div>
  </div>
  <div class="touch-controls" id="joystickArea">
    <div class="joy-base" id="joyBase">
      <div class="joy-arrows">
        <svg class="joy-arrow joy-arrow-up" viewBox="0 0 24 24"><path d="M12 4l-6 6h12z"/></svg>
        <svg class="joy-arrow joy-arrow-down" viewBox="0 0 24 24"><path d="M12 20l6-6H6z"/></svg>
        <svg class="joy-arrow joy-arrow-left" viewBox="0 0 24 24"><path d="M4 12l6 6V6z"/></svg>
        <svg class="joy-arrow joy-arrow-right" viewBox="0 0 24 24"><path d="M20 12l-6-6v12z"/></svg>
      </div>
      <div class="joy-knob" id="joyKnob"></div>
    </div>
  </div>
</div>

<div class="arcade-room" id="desktopLayout">
  <div class="wall"></div>
  <div class="floor"></div>
  <div class="ambient-light a1"></div>
  <div class="ambient-light a2"></div>
  <div class="ambient-light a3"></div>
  <div class="neon-sign left">ARCADE</div>
  <div class="neon-sign right">GAMES</div>
  <div class="bg-cabinet c1"><div></div></div>
  <div class="bg-cabinet c2"><div></div></div>
  <div class="bg-cabinet c3"><div></div></div>
  <div class="bg-cabinet c4"><div></div></div>
  <div class="cabinet">
    <div class="marquee">
      <div class="marquee-text">PAC-MAN</div>
      <div class="marquee-strip"></div>
    </div>
    <div class="cabinet-body">
      <div class="side-art-left"></div>
      <div class="side-art-right"></div>
      <div class="hud">
        <span class="score">SCORE <span id="score">0</span></span>
        <span class="lives" id="lives"></span>
        <span class="best">HIGH <span id="best">0</span></span>
      </div>
      <div class="screen-frame">
        <div class="screen">
          <canvas id="game"></canvas>
          <div class="scanlines"></div>
          <div class="vignette"></div>
          <div class="flicker"></div>
          <div class="reflection"></div>
          <div class="rgb-shift"></div>
        </div>
      </div>
    </div>
    <div class="control-panel">
      <div class="joy-mount">
        <div class="joy-plate">
          <div class="joy-boot"><div class="joy-stick"></div></div>
        </div>
      </div>
      <div class="btn-group">
        <div class="btn-col"><div class="btn red"></div><span class="btn-label">A</span></div>
        <div class="btn-col"><div class="btn blue"></div><span class="btn-label">B</span></div>
        <div class="btn-col"><div class="btn yellow"></div><span class="btn-label">C</span></div>
      </div>
      <div class="btn-start">
        <div class="btn-sm"></div>
        <span class="btn-label">START</span>
      </div>
    </div>
    <div class="lower-panel">
      <div class="coin-row">
        <div class="coin-text">INSERT COIN</div>
        <div class="coin-slot"></div>
      </div>
      <div class="hint">Arrow keys / WASD to move -- Space to start</div>
    </div>
  </div>
</div>

<script>
const isMobile = matchMedia('(pointer: coarse)').matches;
const mobileLayout = document.getElementById('mobileLayout');
const desktopLayout = document.getElementById('desktopLayout');

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

if (isMobile) {
  mobileLayout.style.display = 'flex';
  desktopLayout.style.display = 'none';
  document.getElementById('mobileScreen').insertBefore(canvas, document.getElementById('mobileScreen').firstChild);
}

const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const livesEl = document.getElementById('lives');
const mScoreEl = document.querySelector('.m-score');
const mBestEl = document.querySelector('.m-best');
const mLivesEl = document.querySelector('.m-lives');

const T = 16;
const MAP = [
  "############################",
  "#............##............#",
  "#.####.#####.##.#####.####.#",
  "#O####.#####.##.#####.####O#",
  "#.####.#####.##.#####.####.#",
  "#..........................#",
  "#.####.##.########.##.####.#",
  "#.####.##.########.##.####.#",
  "#......##....##....##......#",
  "######.##### ## #####.######",
  "     #.##### ## #####.#     ",
  "     #.##          ##.#     ",
  "     #.## ###--### ##.#     ",
  "######.## #      # ##.######",
  "      .   #      #   .      ",
  "######.## #      # ##.######",
  "     #.## ######## ##.#     ",
  "     #.##          ##.#     ",
  "     #.## ######## ##.#     ",
  "######.## ######## ##.######",
  "#............##............#",
  "#.####.#####.##.#####.####.#",
  "#.####.#####.##.#####.####.#",
  "#O..##.......  .......##..O#",
  "###.##.##.########.##.##.###",
  "###.##.##.########.##.##.###",
  "#......##....##....##......#",
  "#.##########.##.##########.#",
  "#.##########.##.##########.#",
  "#..........................#",
  "############################",
];

const COLS = MAP[0].length;
const ROWS = MAP.length;
canvas.width = COLS * T;
canvas.height = ROWS * T;

const WALL = 0, DOT = 1, POWER = 2, EMPTY = 3, GATE = 4;

const wallCanvas = document.createElement('canvas');
wallCanvas.width = canvas.width;
wallCanvas.height = canvas.height;
const wallCtx = wallCanvas.getContext('2d');

const dotCanvas = document.createElement('canvas');
dotCanvas.width = canvas.width;
dotCanvas.height = canvas.height;
const dotCtx = dotCanvas.getContext('2d');

let grid, totalDots, dotsEaten, score, best = 0, lives, level;
let player, pacmen, frightTimer, gameState, caughtCount;
let mouthAngle = 0, wallsDirty = true, dotsDirty = true, paused = false;

const BASE_TPS = 7.5;
const GHOST_EATEN_TPS = BASE_TPS * 2;
const SPEED_TABLE = [
  { pn:.80, pd:.71, gn:.75, gf:.50, gt:.40, ft:6 },
  { pn:.90, pd:.79, gn:.85, gf:.55, gt:.45, ft:5 },
  { pn:.90, pd:.79, gn:.85, gf:.55, gt:.45, ft:4 },
  { pn:.90, pd:.79, gn:.85, gf:.55, gt:.45, ft:3 },
  { pn:1.0, pd:.87, gn:.95, gf:.60, gt:.50, ft:2 },
  { pn:.90, pd:.79, gn:.95, gf:.00, gt:.50, ft:0 },
];
function getSpd() { return SPEED_TABLE[Math.min(level - 1, SPEED_TABLE.length - 1)]; }
function inTunnel(x) { return x <= 5 || x >= COLS - 6; }

const GHOST_COLORS = ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852'];

function buildGrid() {
  grid = [];
  totalDots = 0;
  for (let r = 0; r < ROWS; r++) {
    grid[r] = [];
    for (let c = 0; c < COLS; c++) {
      const ch = MAP[r][c];
      if (ch === '#') grid[r][c] = WALL;
      else if (ch === '.') { grid[r][c] = DOT; totalDots++; }
      else if (ch === 'O') { grid[r][c] = POWER; totalDots++; }
      else if (ch === '-') grid[r][c] = GATE;
      else grid[r][c] = EMPTY;
    }
  }
  wallsDirty = true; dotsDirty = true;
}

function canMove(x, y, isGhost, allowGate) {
  if (y < 0 || y >= ROWS) return false;
  if (x < 0 || x >= COLS) return true;
  const cell = grid[y][x];
  if (cell === WALL) return false;
  if (cell === GATE && !allowGate) return false;
  return true;
}

function wrapX(x) {
  if (x < 0) return COLS - 1;
  if (x >= COLS) return 0;
  return x;
}

function dist(ax, ay, bx, by) {
  return Math.abs(ax - bx) + Math.abs(ay - by);
}

function createPlayer() {
  const colorIdx = Math.random() * 4 | 0;
  return {
    x: 14, y: 14, vx: 14, vy: 14,
    dx: 0, dy: -1, nextDx: 0, nextDy: -1,
    moving: false, progress: 0,
    colorIdx: colorIdx, frightened: false
  };
}

function createAIPacman(i) {
  const spawns = [
    { x: 1, y: 1, dx: 1, dy: 0 },
    { x: 26, y: 1, dx: -1, dy: 0 },
    { x: 1, y: 29, dx: 1, dy: 0 },
    { x: 26, y: 29, dx: -1, dy: 0 },
  ];
  const s = spawns[i];
  return {
    x: s.x, y: s.y, vx: s.x, vy: s.y,
    dx: s.dx, dy: s.dy,
    moving: false, progress: 0,
    active: true, idx: i
  };
}

function init() {
  buildGrid();
  dotsEaten = 0; score = 0; lives = 3; level = 1;
  frightTimer = 0; caughtCount = 0;
  player = createPlayer();
  pacmen = [0, 1, 2, 3].map(createAIPacman);
  gameState = 'ready';
  updateHud();
}

function resetPositions() {
  player.x = 14; player.y = 14; player.vx = 14; player.vy = 14;
  player.dx = 0; player.dy = -1; player.nextDx = 0; player.nextDy = -1;
  player.moving = false; player.progress = 0;
  player.frightened = false;
  frightTimer = 0;
  const spawns = [
    { x: 1, y: 1, dx: 1, dy: 0 },
    { x: 26, y: 1, dx: -1, dy: 0 },
    { x: 1, y: 29, dx: 1, dy: 0 },
    { x: 26, y: 29, dx: -1, dy: 0 },
  ];
  for (const p of pacmen) {
    if (!p.active) continue;
    const s = spawns[p.idx];
    p.x = s.x; p.y = s.y; p.vx = s.x; p.vy = s.y;
    p.dx = s.dx; p.dy = s.dy;
    p.moving = false; p.progress = 0;
  }
}

function updateHud() {
  const s = String(score), b = String(best);
  let l = '';
  for (let i = 0; i < lives; i++) l += '\u25CF ';
  l = l.trim();
  if (scoreEl) { scoreEl.textContent = s; bestEl.textContent = b; livesEl.textContent = l; }
  if (mScoreEl) { mScoreEl.textContent = s; mBestEl.textContent = b; mLivesEl.textContent = l; }
}

function findNearestDot(p) {
  let best = null, bestDist = Infinity;
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
    if (grid[r][c] === DOT || grid[r][c] === POWER) {
      const d = dist(c, r, p.x, p.y) + ((c * 7 + r * 13 + p.idx * 31) % 5) - 2;
      if (d < bestDist) { bestDist = d; best = { x: c, y: r }; }
    }
  }
  return best;
}

function pickAIPacDir(p) {
  let target;
  const d = dist(p.x, p.y, player.x, player.y);

  if (player.frightened) {
    target = { x: player.x, y: player.y };
  } else if (d < 8) {
    target = { x: p.x + (p.x - player.x), y: p.y + (p.y - player.y) };
  } else {
    target = findNearestDot(p);
    if (!target) target = { x: Math.random() * COLS | 0, y: Math.random() * ROWS | 0 };
  }

  const dirs = [{ dx: 0, dy: -1 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }];
  const reverse = { dx: -p.dx, dy: -p.dy };
  let bd = Infinity, bdir = null;
  for (const dd of dirs) {
    if (dd.dx === reverse.dx && dd.dy === reverse.dy) continue;
    const nx = wrapX(p.x + dd.dx), ny = p.y + dd.dy;
    if (!canMove(nx, ny, false, false)) continue;
    const distance = dist(nx, ny, target.x, target.y);
    if (distance < bd) { bd = distance; bdir = dd; }
  }
  if (!bdir) {
    const nx = wrapX(p.x + reverse.dx), ny = p.y + reverse.dy;
    if (canMove(nx, ny, false, false)) bdir = reverse;
  }
  return bdir;
}

function update(dt) {
  if (gameState !== 'playing') return;
  mouthAngle = (Math.sin(performance.now() * 0.012) * 0.5 + 0.5) * 0.4;
  if (frightTimer > 0) {
    frightTimer -= dt;
    if (frightTimer <= 0) { frightTimer = 0; player.frightened = false; }
  }
  updatePlayer(dt);
  for (const p of pacmen) { if (p.active) updateAIPacman(p, dt); }
  checkCollisions();
  updateHud();
}

function updatePlayer(dt) {
  const spd = getSpd();
  const speed = BASE_TPS * spd.pn;
  let rem = dt * speed;
  while (rem > 0.001) {
    if (!player.moving) {
      if (canMove(wrapX(player.x + player.nextDx), player.y + player.nextDy, true, true))
        { player.dx = player.nextDx; player.dy = player.nextDy; }
      if (canMove(wrapX(player.x + player.dx), player.y + player.dy, true, true))
        { player.moving = true; player.progress = 0; }
      else break;
    }
    const step = Math.min(rem, 1 - player.progress);
    player.progress += step; rem -= step;
    player.vx = player.x + player.dx * player.progress;
    player.vy = player.y + player.dy * player.progress;
    if (player.dx === -1 && player.x === 0) player.vx = player.x - player.progress;
    if (player.dx === 1 && player.x === COLS - 1) player.vx = player.x + player.progress;
    if (player.progress >= 1) {
      player.x = wrapX(player.x + player.dx); player.y += player.dy;
      player.vx = player.x; player.vy = player.y;
      player.moving = false; player.progress = 0;
    }
  }
}

function updateAIPacman(p, dt) {
  const spd = getSpd();
  const speed = BASE_TPS * (player.frightened ? (spd.gf || spd.gn) : spd.gn);
  let rem = dt * speed;
  while (rem > 0.001) {
    if (!p.moving) {
      const dir = pickAIPacDir(p);
      if (!dir) break;
      p.dx = dir.dx; p.dy = dir.dy;
      p.moving = true; p.progress = 0;
    }
    const step = Math.min(rem, 1 - p.progress);
    p.progress += step; rem -= step;
    p.vx = p.x + p.dx * p.progress;
    p.vy = p.y + p.dy * p.progress;
    if (p.dx === -1 && p.x === 0) p.vx = p.x - p.progress;
    if (p.dx === 1 && p.x === COLS - 1) p.vx = p.x + p.progress;
    if (p.progress >= 1) {
      p.x = wrapX(p.x + p.dx); p.y += p.dy;
      p.vx = p.x; p.vy = p.y; p.moving = false; p.progress = 0;
      const cell = grid[p.y][p.x];
      if (cell === DOT) {
        grid[p.y][p.x] = EMPTY; dotsEaten++;
        dotCtx.clearRect(p.x * T, p.y * T, T, T);
      } else if (cell === POWER) {
        grid[p.y][p.x] = EMPTY; dotsEaten++;
        dotCtx.clearRect(p.x * T, p.y * T, T, T);
        if (spd.ft > 0) { frightTimer = spd.ft; player.frightened = true; }
      }
    }
  }
}

function checkCollisions() {
  for (const p of pacmen) {
    if (!p.active) continue;
    if (Math.abs(p.vx - player.vx) < 0.7 && Math.abs(p.vy - player.vy) < 0.7) {
      if (!player.frightened) {
        p.active = false; score += 200; caughtCount++;
        if (caughtCount >= 4) {
          level++; buildGrid(); dotsEaten = 0; caughtCount = 0;
          pacmen = [0, 1, 2, 3].map(createAIPacman);
          player.x = 14; player.y = 14; player.vx = 14; player.vy = 14;
          player.dx = 0; player.dy = -1; player.nextDx = 0; player.nextDy = -1;
          player.moving = false; player.progress = 0;
          player.frightened = false; frightTimer = 0;
          gameState = 'ready';
          return;
        }
      } else {
        lives--;
        updateHud();
        if (lives <= 0) {
          if (score > best) best = score;
          gameState = 'gameover';
        } else {
          resetPositions(); gameState = 'ready';
        }
        return;
      }
    }
  }
}

function renderWalls() {
  wallCtx.clearRect(0, 0, wallCanvas.width, wallCanvas.height);
  wallCtx.strokeStyle = '#2121de'; wallCtx.lineWidth = 2;
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
    if (grid[r][c] !== WALL) continue;
    const x = c * T, y = r * T;
    const u = r > 0 && grid[r-1][c] === WALL, d = r < ROWS-1 && grid[r+1][c] === WALL;
    const l = c > 0 && grid[r][c-1] === WALL, rt = c < COLS-1 && grid[r][c+1] === WALL;
    if (!u) { wallCtx.beginPath(); wallCtx.moveTo(x, y+1); wallCtx.lineTo(x+T, y+1); wallCtx.stroke(); }
    if (!d) { wallCtx.beginPath(); wallCtx.moveTo(x, y+T-1); wallCtx.lineTo(x+T, y+T-1); wallCtx.stroke(); }
    if (!l) { wallCtx.beginPath(); wallCtx.moveTo(x+1, y); wallCtx.lineTo(x+1, y+T); wallCtx.stroke(); }
    if (!rt) { wallCtx.beginPath(); wallCtx.moveTo(x+T-1, y); wallCtx.lineTo(x+T-1, y+T); wallCtx.stroke(); }
  }
  wallCtx.strokeStyle = '#ffb8ff'; wallCtx.lineWidth = 2;
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
    if (grid[r][c] !== GATE) continue;
    wallCtx.beginPath(); wallCtx.moveTo(c*T, r*T+T/2); wallCtx.lineTo(c*T+T, r*T+T/2); wallCtx.stroke();
  }
  wallsDirty = false;
}

function renderDots() {
  dotCtx.clearRect(0, 0, dotCanvas.width, dotCanvas.height);
  dotCtx.fillStyle = '#ffb8ae';
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
    if (grid[r][c] === DOT) { dotCtx.beginPath(); dotCtx.arc(c * T + T / 2, r * T + T / 2, 2, 0, Math.PI * 2); dotCtx.fill(); }
  }
  dotsDirty = false;
}

function drawPowerPellets(time) {
  ctx.globalAlpha = Math.sin(time * 0.005) * 0.3 + 0.7;
  ctx.fillStyle = '#ffb8ae';
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
    if (grid[r][c] === POWER) { ctx.beginPath(); ctx.arc(c * T + T / 2, r * T + T / 2, 5, 0, Math.PI * 2); ctx.fill(); }
  }
  ctx.globalAlpha = 1;
}

function drawPlayer(time) {
  const x = (player.vx * T + T / 2) | 0, y = (player.vy * T + T / 2) | 0, r = T / 2 - 1;
  const fl = player.frightened && frightTimer < 2 && (Math.sin(time * 0.02) > 0);
  ctx.fillStyle = player.frightened ? (fl ? '#fff' : '#2121de') : GHOST_COLORS[player.colorIdx];
  ctx.beginPath(); ctx.arc(x, y - 2, r, Math.PI, 0); ctx.lineTo(x + r, y + r - 2);
  const lw = (r * 2) / 3;
  for (let i = 0; i < 3; i++) {
    const lx = x + r - i * lw;
    ctx.lineTo(lx - lw / 2, y + r - 2 + Math.sin(time * 0.008 + i * 2) * 2);
    ctx.lineTo(lx - lw, y + r - 2);
  }
  ctx.closePath(); ctx.fill();
  if (!player.frightened) {
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(x - 3, y - 3, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 3, y - 3, 3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#00f';
    ctx.beginPath(); ctx.arc(x - 3 + player.dx, y - 3 + player.dy, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 3 + player.dx, y - 3 + player.dy, 1.5, 0, Math.PI * 2); ctx.fill();
  } else {
    ctx.fillStyle = fl ? '#f00' : '#ffb8ae';
    ctx.beginPath(); ctx.arc(x - 3, y - 2, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 3, y - 2, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = ctx.fillStyle; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x - 5, y + 3);
    for (let i = 0; i < 5; i++) ctx.lineTo(x - 5 + i * 2.5, y + (i % 2 === 0 ? 3 : 5));
    ctx.stroke();
  }
}

function drawAIPacman(p, time) {
  if (!p.active) return;
  const x = (p.vx * T + T / 2) | 0, y = (p.vy * T + T / 2) | 0;
  let angle = 0;
  if (p.dx === 1) angle = 0;
  else if (p.dx === -1) angle = Math.PI;
  else if (p.dy === -1) angle = -Math.PI / 2;
  else if (p.dy === 1) angle = Math.PI / 2;
  ctx.fillStyle = '#ffff00';
  ctx.beginPath();
  ctx.arc(x, y, T / 2 - 1, angle + (p.moving ? mouthAngle : 0.05),
    angle + Math.PI * 2 - (p.moving ? mouthAngle : 0.05));
  ctx.lineTo(x, y); ctx.closePath(); ctx.fill();
}

function draw(time) {
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  if (wallsDirty) renderWalls();
  if (dotsDirty) renderDots();
  ctx.drawImage(wallCanvas, 0, 0);
  ctx.drawImage(dotCanvas, 0, 0);
  drawPowerPellets(time);
  if (gameState==='playing'||gameState==='ready') { for (const p of pacmen) drawAIPacman(p, time); drawPlayer(time); }
  ctx.textAlign='center'; ctx.font='14px "Press Start 2P", monospace';
  if (gameState==='ready') { ctx.fillStyle='#ffff00'; ctx.fillText('READY!', canvas.width/2, 17*T+T/2); }
  if (gameState==='gameover') {
    ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#ff0000'; ctx.font='22px "Press Start 2P", monospace'; ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2-10);
    ctx.fillStyle='#ffff00'; ctx.font='10px "Press Start 2P", monospace'; ctx.fillText(isMobile?'TAP TO RETRY':'PRESS SPACE', canvas.width/2, canvas.height/2+20);
  }
}

function startOrRestart() {
  if (gameState==='gameover') init();
  else if (gameState==='ready') gameState='playing';
}

document.addEventListener('keydown', e => {
  const key = e.key;
  if (gameState==='ready'||gameState==='gameover') { if (key===' ') startOrRestart(); }
  else {
    switch (key) {
      case 'ArrowUp': case 'w': case 'W': player.nextDx=0; player.nextDy=-1; break;
      case 'ArrowDown': case 's': case 'S': player.nextDx=0; player.nextDy=1; break;
      case 'ArrowLeft': case 'a': case 'A': player.nextDx=-1; player.nextDy=0; break;
      case 'ArrowRight': case 'd': case 'D': player.nextDx=1; player.nextDy=0; break;
    }
  }
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(key)) e.preventDefault();
});

const joyBase = document.getElementById('joyBase');
const joyKnob = document.getElementById('joyKnob');
const joyArrows = document.querySelectorAll('.joy-arrow');
let joyActive = false, joyCenterX = 0, joyCenterY = 0;
const JOY_MAX = 40, JOY_DEAD = 12;

if (joyBase) {
  joyBase.addEventListener('touchstart', e => {
    e.preventDefault();
    joyActive = true;
    joyKnob.classList.add('active');
    if (gameState==='ready'||gameState==='gameover') startOrRestart();
    const rect = joyBase.getBoundingClientRect();
    joyCenterX = rect.left + rect.width / 2;
    joyCenterY = rect.top + rect.height / 2;
    handleJoyMove(e.touches[0]);
  }, { passive: false });

  joyBase.addEventListener('touchmove', e => {
    e.preventDefault();
    if (joyActive) handleJoyMove(e.touches[0]);
  }, { passive: false });

  function joyEnd(e) {
    e.preventDefault();
    joyActive = false;
    joyKnob.classList.remove('active');
    joyKnob.style.transform = 'translate(-50%, -50%)';
    joyArrows.forEach(a => a.classList.remove('lit'));
  }
  joyBase.addEventListener('touchend', joyEnd, { passive: false });
  joyBase.addEventListener('touchcancel', joyEnd, { passive: false });
}

function handleJoyMove(touch) {
  let dx = touch.clientX - joyCenterX;
  let dy = touch.clientY - joyCenterY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > JOY_MAX) { dx = dx / dist * JOY_MAX; dy = dy / dist * JOY_MAX; }
  joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  joyArrows.forEach(a => a.classList.remove('lit'));
  if (dist > JOY_DEAD) {
    if (Math.abs(dx) > Math.abs(dy)) {
      player.nextDx = dx > 0 ? 1 : -1; player.nextDy = 0;
      document.querySelector(dx > 0 ? '.joy-arrow-right' : '.joy-arrow-left')?.classList.add('lit');
    } else {
      player.nextDx = 0; player.nextDy = dy > 0 ? 1 : -1;
      document.querySelector(dy > 0 ? '.joy-arrow-down' : '.joy-arrow-up')?.classList.add('lit');
    }
  }
}

let touchStartX = 0, touchStartY = 0;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (gameState==='ready'||gameState==='gameover') { startOrRestart(); return; }
  const t = e.touches[0]; touchStartX = t.clientX; touchStartY = t.clientY;
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (gameState !== 'playing') return;
  const t = e.touches[0];
  const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
  if (Math.abs(dx) < 12 && Math.abs(dy) < 12) return;
  if (Math.abs(dx) > Math.abs(dy)) { player.nextDx = dx > 0 ? 1 : -1; player.nextDy = 0; }
  else { player.nextDx = 0; player.nextDy = dy > 0 ? 1 : -1; }
  touchStartX = t.clientX; touchStartY = t.clientY;
}, { passive: false });

document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

document.addEventListener('visibilitychange', () => {
  paused = document.hidden;
  if (!paused) lastTime = performance.now();
});

let lastTime = 0;
function gameLoop(time) {
  if (!paused) {
    const dt = Math.min((time - lastTime) / 1000, 0.05);
    update(dt);
    draw(time);
  }
  lastTime = time;
  requestAnimationFrame(gameLoop);
}

init();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
